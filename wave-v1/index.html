<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>HardWave - Telegram Media Display</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      background: #000;
      overflow: hidden;
      padding-right: 40px;
      cursor: none;
    }
    iframe {
      width: 100%;
      height: 100%;
      border: none;
    }
    .key-display-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      z-index: 9999;
    }
    .key-display-text {
      font-size: 20vw;
      font-weight: bold;
      color: red;
      -webkit-text-stroke: 4px blue;
      text-stroke: 4px blue;
      paint-order: stroke fill;
      opacity: 0;
      transform: scale(1);
      transition: none;
      text-align: center;
      max-width: 90%;
    }
    .key-display-text.visible {
      opacity: 1;
      transform: scale(1);
    }
    .key-display-text.fading {
      opacity: 0;
      transform: scale(1.5);
      transition: opacity 0.8s ease-out, transform 0.8s ease-out;
    }
  </style>
</head>
<body>
  <div class="key-display-overlay"><div class="key-display-text" id="keyDisplay"></div></div>
  <iframe id="displayFrame" sandbox="allow-scripts" src="plugin-media-display.html"></iframe>

  <script>
    // ============================================================
    // CONFIG - All configurable constants in one place
    // ============================================================
    const CONFIG = {
      CHAT_NAME: '@xexecut_chat',
      TIMEZONE: 'Europe/Belgrade',

      // WebHID Device
      HID_VENDOR_ID: 0x239A,
      HID_PRODUCT_ID: 0x80B4,
      HID_USAGE_PAGE: 0xFF00,
      HID_USAGE: 0x01,
      HID_REPORT_ID: 0x04,
      HID_REPORT_LENGTH: 48,
      HID_TEXT_MAX_LENGTH: 46,

      // HID Commands
      CMD_RUNNING_TEXT: 0x10,
      CMD_TIME_SYNC: 0x12,
      CMD_RAW: 0x14,

      // Timing
      TIME_SYNC_INTERVAL_MS: 60 * 60 * 1000,
      POLL_TIMEOUT_SECONDS: 30,
      KEY_DISPLAY_DURATION_MS: 1000,
      KEY_FADE_DURATION_MS: 800,
    };

    // Plugin registry: name -> path
    const PLUGINS = {
      'media': 'plugin-media-display.html',
    };

    const DEFAULT_PLUGIN = 'media';

    // Key mapping from hardware buttons
    const KEY_MAP = {
      'c': 'COOK',
      'C': 'COOK',
      'd': 'DEFROST',
      'D': 'DEFROST',
      'r': 'REHEAT',
      'R': 'REHEAT',
      'w': 'WAVES',
      'W': 'WAVES',
      't': 'TIME',
      'T': 'TIME',
      'e': 'ELEMENTS',
      'E': 'ELEMENTS',
      '+': 'PLUS',
      '-': 'MINUS',
      'z': 'TEN_MIN',
      'Z': 'TEN_MIN',
      'y': 'ONE_MIN',
      'Y': 'ONE_MIN',
      'x': 'TEN_SEC',
      'X': 'TEN_SEC',
      'Escape': 'STOP',
      'Enter': 'START',
    };

    const displayFrame = document.getElementById('displayFrame');
    const keyDisplayEl = document.getElementById('keyDisplay');

    // ============================================================
    // PluginManager - Load and manage plugins
    // ============================================================
    const PluginManager = (function() {
      let currentPlugin = DEFAULT_PLUGIN;
      let onLoadCallback = null;

      function getPluginList() {
        return Object.keys(PLUGINS);
      }

      function loadPlugin(nameOrUrl) {
        const pluginPath = PLUGINS[nameOrUrl] || nameOrUrl;
        currentPlugin = nameOrUrl;
        console.log('[PluginManager] Loading plugin:', nameOrUrl, '->', pluginPath);
        displayFrame.src = pluginPath;
      }

      function getCurrentPlugin() {
        return currentPlugin;
      }

      function setOnLoadCallback(callback) {
        onLoadCallback = callback;
      }

      function triggerOnLoad() {
        if (onLoadCallback) onLoadCallback();
      }

      displayFrame.addEventListener('load', () => {
        triggerOnLoad();
      });

      return { getPluginList, loadPlugin, getCurrentPlugin, setOnLoadCallback };
    })();

    // ============================================================
    // KeyDisplay - Key overlay handler (in parent)
    // ============================================================
    const KeyDisplay = (function() {
      let fadeTimeout = null;
      let removeTimeout = null;
      let enabled = false;

      function show(key) {
        if (!enabled) return;

        if (fadeTimeout) clearTimeout(fadeTimeout);
        if (removeTimeout) clearTimeout(removeTimeout);

        const displayName = KEY_MAP[key] || key.toUpperCase();
        keyDisplayEl.classList.remove('fading');
        keyDisplayEl.classList.remove('visible');
        keyDisplayEl.textContent = displayName;

        void keyDisplayEl.offsetWidth;

        keyDisplayEl.classList.add('visible');

        fadeTimeout = setTimeout(() => {
          keyDisplayEl.classList.add('fading');
          keyDisplayEl.classList.remove('visible');

          removeTimeout = setTimeout(() => {
            keyDisplayEl.classList.remove('fading');
          }, CONFIG.KEY_FADE_DURATION_MS);
        }, CONFIG.KEY_DISPLAY_DURATION_MS);
      }

      function setEnabled(value) {
        enabled = value;
        if (!enabled) {
          keyDisplayEl.classList.remove('visible', 'fading');
        }
      }

      return { show, setEnabled };
    })();

    // ============================================================
    // KeyboardCommands - WebHID hardware interface
    // ============================================================
    const KeyboardCommands = (function() {
      let dev = null;

      const MACCYRILLIC_LOOKUP = {
        0x2020: 0xA0, 0x00B0: 0xA1, 0x0490: 0xA2, 0x00A3: 0xA3, 0x00A7: 0xA4,
        0x2022: 0xA5, 0x00B6: 0xA6, 0x0406: 0xA7, 0x00AE: 0xA8, 0x00A9: 0xA9,
        0x2122: 0xAA, 0x0402: 0xAB, 0x0452: 0xAC, 0x2260: 0xAD, 0x0403: 0xAE,
        0x0453: 0xAF, 0x221E: 0xB0, 0x00B1: 0xB1, 0x2264: 0xB2, 0x2265: 0xB3,
        0x0456: 0xB4, 0x00B5: 0xB5, 0x0491: 0xB6, 0x0408: 0xB7, 0x0404: 0xB8,
        0x0454: 0xB9, 0x0407: 0xBA, 0x0457: 0xBB, 0x0409: 0xBC, 0x0459: 0xBD,
        0x040A: 0xBE, 0x045A: 0xBF, 0x0458: 0xC0, 0x0405: 0xC1, 0x00AC: 0xC2,
        0x221A: 0xC3, 0x0192: 0xC4, 0x2248: 0xC5, 0x2206: 0xC6, 0x00AB: 0xC7,
        0x00BB: 0xC8, 0x2026: 0xC9, 0x00A0: 0xCA, 0x040B: 0xCB, 0x045B: 0xCC,
        0x040C: 0xCD, 0x045C: 0xCE, 0x0455: 0xCF, 0x2013: 0xD0, 0x2014: 0xD1,
        0x201C: 0xD2, 0x201D: 0xD3, 0x2018: 0xD4, 0x2019: 0xD5, 0x00F7: 0xD6,
        0x201E: 0xD7, 0x040E: 0xD8, 0x045E: 0xD9, 0x040F: 0xDA, 0x045F: 0xDB,
        0x2116: 0xDC, 0x0401: 0xDD, 0x0451: 0xDE, 0x044F: 0xDF, 0x20AC: 0xFF,
      };

      function encode(text) {
        text = text + "";
        const payload = new Uint8Array(text.length);

        for (let i = 0; i < text.length; i++) {
          let code = text.charCodeAt(i);
          if (code >= 0x20 && code <= 0x7f) {
            payload[i] = code;
          } else if (code >= 0x0410 && code <= 0x042f) {
            payload[i] = code - 0x0390;
          } else if (code >= 0x0430 && code <= 0x044e) {
            payload[i] = code - 0x0350;
          } else {
            let macCode = MACCYRILLIC_LOOKUP[code];
            if (macCode === undefined) {
              throw new Error('Symbol not available in Mac encoding: 0x' + code.toString(16));
            }
            payload[i] = macCode;
          }
        }

        return payload;
      }

      function handleDisconnect(event) {
        if (dev && event.device === dev) {
          console.log('[KeyboardCommands] Device disconnected');
          dev = null;
        }
      }

      async function ensureDevice() {
        if (!("hid" in navigator)) throw new Error("WebHID not available");
        if (dev && dev.opened) return dev;

        const { HID_VENDOR_ID, HID_PRODUCT_ID, HID_USAGE_PAGE, HID_USAGE } = CONFIG;

        const granted = await navigator.hid.getDevices();
        dev = granted.find(d => d.vendorId === HID_VENDOR_ID && d.productId === HID_PRODUCT_ID) || null;

        if (!dev) {
          const picked = await navigator.hid.requestDevice({
            filters: [{ vendorId: HID_VENDOR_ID, productId: HID_PRODUCT_ID, usagePage: HID_USAGE_PAGE, usage: HID_USAGE }]
          });
          dev = picked?.[0] || null;
        }

        if (!dev) throw new Error("No device selected");
        if (!dev.opened) await dev.open();

        return dev;
      }

      function getCurrentTime() {
        const now = new Date();
        const parts = new Intl.DateTimeFormat("en-GB", {
          timeZone: CONFIG.TIMEZONE,
          year: "numeric",
          month: "2-digit",
          day: "2-digit",
          hour: "2-digit",
          minute: "2-digit",
          second: "2-digit",
          hour12: false,
        }).formatToParts(now);

        const map = Object.fromEntries(parts.filter(p => p.type !== "literal").map(p => [p.type, p.value]));
        const y = Number(map.year);
        const mo = Number(map.month);
        const d = Number(map.day);
        const h = Number(map.hour);
        const mi = Number(map.minute);
        const s = Number(map.second);

        return Math.floor(Date.UTC(y, mo - 1, d, h, mi, s) / 1000);
      }

      async function sendCommand(type, data) {
        const device = await ensureDevice();
        const payload = new Uint8Array(CONFIG.HID_REPORT_LENGTH);

        if (type === 'timeSync') {
          payload[0] = CONFIG.CMD_TIME_SYNC;
          const ts = data !== undefined ? data : getCurrentTime();
          const dv = new DataView(payload.buffer);
          dv.setUint32(1, ts >>> 0, true);
          console.log('[KeyboardCommands] Sending time sync:', ts, '(' + new Date(ts * 1000).toISOString() + ')');
        } else if (type === 'runningText') {
          payload[0] = CONFIG.CMD_RUNNING_TEXT;
          let bytes = encode(data || '');
          if (bytes.length > CONFIG.HID_TEXT_MAX_LENGTH) bytes = bytes.slice(0, CONFIG.HID_TEXT_MAX_LENGTH);
          payload.set(bytes, 1);
          payload[1 + bytes.length] = 0x00;
          console.log('[KeyboardCommands] Sending running text:', data);
        } else if (type === 'raw') {
          payload[0] = CONFIG.CMD_RAW;
          const digits = data.digits || [0, 0, 0, 0];
          const symbols = data.symbols || 0;
          payload[1] = digits[0] & 0x7F;
          payload[2] = digits[1] & 0x7F;
          payload[3] = digits[2] & 0x7F;
          payload[4] = digits[3] & 0x7F;
          payload[5] = symbols & 0xFF;
          payload[6] = (symbols >> 8) & 0x0F;
          console.log('[KeyboardCommands] Sending raw:', { digits, symbols });
        } else {
          throw new Error('Unknown command type: ' + type);
        }

        await device.sendReport(CONFIG.HID_REPORT_ID, payload);
      }

      if ("hid" in navigator) {
        navigator.hid.addEventListener('disconnect', handleDisconnect);
      }

      // Initial time sync
      (async () => {
        try {
          await sendCommand('timeSync');
          console.log('[KeyboardCommands] Initial time sync completed');
        } catch (e) {
          console.log('[KeyboardCommands] Initial time sync skipped (no device):', e.message);
        }
      })();

      // Periodic time sync
      setInterval(async () => {
        try {
          await sendCommand('timeSync');
          console.log('[KeyboardCommands] Periodic time sync completed');
        } catch (e) {
          console.log('[KeyboardCommands] Periodic time sync failed:', e.message);
        }
      }, CONFIG.TIME_SYNC_INTERVAL_MS);

      return { sendCommand, ensureDevice };
    })();

    // ============================================================
    // Handle messages from child iframe
    // ============================================================
    window.addEventListener('message', async (event) => {
      if (event.source !== displayFrame.contentWindow) return;

      const msg = event.data;
      if (!msg || !msg.type) return;

      if (msg.type === 'hid') {
        console.log('[Parent] Received HID command from child:', msg);
        try {
          if (msg.command === 'runningText') {
            await KeyboardCommands.sendCommand('runningText', msg.text);
            sendToChild({ type: 'hidResult', success: true, command: msg.command });
          } else if (msg.command === 'raw') {
            await KeyboardCommands.sendCommand('raw', { digits: msg.digits, symbols: msg.symbols });
            sendToChild({ type: 'hidResult', success: true, command: msg.command });
          }
        } catch (err) {
          console.error('[Parent] HID command failed:', err);
          sendToChild({ type: 'hidResult', success: false, command: msg.command, error: err.message });
        }
      } else if (msg.type === 'keyDisplayMode') {
        KeyDisplay.setEnabled(msg.enabled);
        console.log('[Parent] Key display mode:', msg.enabled ? 'on' : 'off');
      }
    });

    // ============================================================
    // Forward keypresses to child iframe
    // ============================================================
    document.addEventListener('keydown', (e) => {
      KeyDisplay.show(e.key);
      const description = KEY_MAP[e.key] || null;
      sendToChild({ type: 'keypress', key: e.key, description });
    });

    function sendToChild(msg) {
      displayFrame.contentWindow.postMessage(msg, '*');
    }

    // ============================================================
    // TelegramAPI - Telegram Bot API interface
    // ============================================================
    const TelegramAPI = (function() {
      let apiKey = null;

      function init(key) {
        apiKey = key;
      }

      async function sendReaction(chatId, messageId, emoji) {
        try {
          await fetch(`https://api.telegram.org/bot${apiKey}/setMessageReaction`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              chat_id: chatId,
              message_id: messageId,
              reaction: [{ type: 'emoji', emoji }]
            })
          });
        } catch (err) {
          console.error('[TelegramAPI] Failed to send reaction:', err);
        }
      }

      async function getFileUrl(fileId) {
        const res = await fetch(`https://api.telegram.org/bot${apiKey}/getFile?file_id=${fileId}`);
        const data = await res.json();
        if (!data.ok) {
          throw new Error('Telegram API error: ' + JSON.stringify(data));
        }
        console.log('[TelegramAPI] File fetched:', data.result.file_path);
        return `https://api.telegram.org/file/bot${apiKey}/${data.result.file_path}`;
      }

      async function getUpdates(offset) {
        const url = `https://api.telegram.org/bot${apiKey}/getUpdates?offset=${offset}&timeout=${CONFIG.POLL_TIMEOUT_SECONDS}`;
        const res = await fetch(url);
        return await res.json();
      }

      async function acknowledgeUpdate(offset) {
        const res = await fetch(`https://api.telegram.org/bot${apiKey}/getUpdates?offset=${offset}&timeout=0`);
        await res.json();
      }

      async function sendMessage(chatId, text) {
        try {
          await fetch(`https://api.telegram.org/bot${apiKey}/sendMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              chat_id: chatId,
              text: text
            })
          });
        } catch (err) {
          console.error('[TelegramAPI] Failed to send message:', err);
        }
      }

      return { init, sendReaction, getFileUrl, getUpdates, acknowledgeUpdate, sendMessage };
    })();

    // ============================================================
    // Main Application
    // ============================================================
    (async function Main() {
      console.log('[INIT] Starting Telegram Updates viewer (parent frame)');

      // Parse URL parameters
      const params = new URLSearchParams(window.location.search);
      const queryKey = params.get('api_key');
      const keepAspectRatio = params.get('respect_aspect_ratio') === '1' || params.get('respect_aspect_ratio') === 'true';
      const requireUsername = params.get('require_username') === '1' || params.get('require_username') === 'true';
      const allowedChatId = params.get('chat_id') || null;
      const adminIdsParam = params.get('admin_ids');

      console.log('[CONFIG] URL parameters:', { hasApiKey: !!queryKey, keepAspectRatio, requireUsername, allowedChatId, adminIdsParam });

      // Validate required params
      if (!queryKey) {
        console.error('[CONFIG] No API key found in URL - aborting');
        PluginManager.setOnLoadCallback(() => sendToChild({ type: 'error', message: 'api_key not found in URL' }));
        return;
      }
      if (!allowedChatId) {
        console.error('[CONFIG] No chat_id found in URL - aborting');
        PluginManager.setOnLoadCallback(() => sendToChild({ type: 'error', message: 'chat_id not found in URL' }));
        return;
      }
      if (!adminIdsParam) {
        console.error('[CONFIG] No admin_ids found in URL - aborting');
        PluginManager.setOnLoadCallback(() => sendToChild({ type: 'error', message: 'admin_ids not found in URL' }));
        return;
      }

      const adminIds = adminIdsParam.split(',').map(id => parseInt(id.trim(), 10));
      TelegramAPI.init(queryKey);
      console.log('[CONFIG] API key loaded from URL');

      let offset = 0;

      // Display status from localStorage
      const DISPLAY_STATUS_KEY = 'hardwave_display_enabled';
      let displayEnabled = localStorage.getItem(DISPLAY_STATUS_KEY) !== 'off';
      console.log('[CONFIG] Display enabled:', displayEnabled);

      PluginManager.setOnLoadCallback(() => {
        sendToChild({ type: 'init', chatName: CONFIG.CHAT_NAME, keepAspectRatio });
        if (!displayEnabled) {
          sendToChild({ type: 'displayOff' });
        }
      });

      function isAdminCommand(message, commandText) {
        const isFromAdmin = message.from && adminIds.includes(message.from.id);
        const isForwarded = message.forward_from || message.forward_from_chat || message.forward_date || message.forward_origin;
        const isCommand = (message.text || '') === commandText;
        return isFromAdmin && !isForwarded && isCommand;
      }

      function isAdminCommandPrefix(message, commandPrefix) {
        const isFromAdmin = message.from && adminIds.includes(message.from.id);
        const isForwarded = message.forward_from || message.forward_from_chat || message.forward_date || message.forward_origin;
        const text = message.text || '';
        const isCommand = text === commandPrefix || text.startsWith(commandPrefix + ' ');
        return isFromAdmin && !isForwarded && isCommand;
      }

      function extractMediaInfo(message) {
        if (message.photo?.length > 0) {
          return { fileId: message.photo[message.photo.length - 1].file_id, isVideo: false };
        }
        if (message.animation) return { fileId: message.animation.file_id, isVideo: true };
        if (message.video) return { fileId: message.video.file_id, isVideo: true };
        if (message.video_note) return { fileId: message.video_note.file_id, isVideo: true };
        return null;
      }

      async function processUpdate(update) {
        console.log('[POLL] Processing update:', { update_id: update.update_id });

        const message = update.message;
        if (!message) {
          console.log('[POLL] Skipping update - no message field present');
          return;
        }

        const isFromAdmin = message.from && adminIds.includes(message.from.id);

        // Handle admin commands in parent
        if (isAdminCommand(message, '/off')) {
          console.log('[COMMAND] /off triggered by admin:', message.from.id);
          displayEnabled = false;
          localStorage.setItem(DISPLAY_STATUS_KEY, 'off');
          sendToChild({ type: 'displayOff' });
          await TelegramAPI.sendReaction(message.chat.id, message.message_id, 'ðŸ‘€');
          return;
        }

        if (isAdminCommand(message, '/on')) {
          console.log('[COMMAND] /on triggered by admin:', message.from.id);
          displayEnabled = true;
          localStorage.setItem(DISPLAY_STATUS_KEY, 'on');
          sendToChild({ type: 'displayOn' });
          await TelegramAPI.sendReaction(message.chat.id, message.message_id, 'ðŸ‘€');
          return;
        }

        if (isAdminCommand(message, '/reload')) {
          console.log('[COMMAND] /reload triggered by admin:', message.from.id);
          await TelegramAPI.sendReaction(message.chat.id, message.message_id, 'ðŸ‘€');
          await TelegramAPI.acknowledgeUpdate(update.update_id + 1);
          console.log('[COMMAND] Reload acknowledged, reloading page...');
          location.reload();
          return;
        }

        if (isAdminCommandPrefix(message, '/plugin')) {
          const text = message.text || '';
          const arg = text.substring('/plugin'.length).trim();

          if (!arg) {
            // List available plugins
            const plugins = PluginManager.getPluginList();
            const current = PluginManager.getCurrentPlugin();
            const list = plugins.map(p => (p === current ? `* ${p}` : `  ${p}`)).join('\n');
            await TelegramAPI.sendMessage(message.chat.id, `Available plugins:\n${list}\n\nUsage: /plugin <name|url>`);
            await TelegramAPI.sendReaction(message.chat.id, message.message_id, 'ðŸ‘€');
          } else {
            // Load plugin by name or URL
            console.log('[COMMAND] /plugin triggered by admin:', message.from.id, 'arg:', arg);
            PluginManager.loadPlugin(arg);
            await TelegramAPI.sendReaction(message.chat.id, message.message_id, 'ðŸ‘€');
          }
          return;
        }

        // When display is off, ignore non-admin messages
        if (!displayEnabled && !isFromAdmin) {
          console.log('[POLL] Skipping - display is off and message is from non-admin');
          return;
        }

        // Filter checks
        if (allowedChatId && String(message.chat.id) !== allowedChatId) {
          console.log('[POLL] Skipping - chat_id mismatch');
          return;
        }
        if (requireUsername && !message.from.username) {
          console.log('[POLL] Skipping - user has no username');
          return;
        }
        if (message.has_media_spoiler) {
          console.log('[POLL] Skipping - has media spoiler');
          return;
        }

        const sender = message.from.first_name + (message.from.username ? ' @' + message.from.username : '');
        const text = message.text || message.caption || '';
        const media = extractMediaInfo(message);

        // Send command text to child if starts with /
        if (text.startsWith('/')) {
          sendToChild({
            type: 'command',
            text: text,
            sender: sender,
            isAdmin: isFromAdmin,
            chatId: message.chat.id,
            messageId: message.message_id
          });
        }

        // Process and send media to child
        if (media && displayEnabled) {
          try {
            const fileUrl = await TelegramAPI.getFileUrl(media.fileId);
            const payload = {
              type: 'media',
              sender: sender,
              isAdmin: isFromAdmin
            };
            if (media.isVideo) {
              payload.videoUrl = fileUrl;
            } else {
              payload.photoUrl = fileUrl;
            }
            sendToChild(payload);
            await TelegramAPI.sendReaction(message.chat.id, message.message_id, 'ðŸ‘€');
          } catch (err) {
            console.error('[Parent] Failed to fetch/display media:', err);
          }
        }
      }

      async function pollUpdates() {
        while (true) {
          console.log('[POLL] Starting long-poll with offset:', offset);
          try {
            const data = await TelegramAPI.getUpdates(offset);

            if (data.ok && data.result.length > 0) {
              console.log('[POLL] Received', data.result.length, 'update(s)');
              for (const update of data.result) {
                await processUpdate(update);
                offset = update.update_id + 1;
              }
            } else if (data.ok) {
              console.log('[POLL] No new updates (timeout reached)');
            } else {
              console.error('[POLL] API returned error:', data);
            }
          } catch (e) {
            console.error('[POLL] Polling error:', e);
          }
        }
      }

      // Listen for reaction requests from child (added to main message handler above)
      window.addEventListener('message', async (event) => {
        if (event.source !== displayFrame.contentWindow) return;
        const msg = event.data;
        if (msg?.type === 'reaction') {
          await TelegramAPI.sendReaction(msg.chatId, msg.messageId, msg.emoji);
        }
      });

      console.log('[INIT] Starting polling loop');
      await pollUpdates();
    })();
  </script>
</body>
</html>
